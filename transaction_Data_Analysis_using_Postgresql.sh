# Create a new table called bank_accounts
CREATE TABLE bank_accounts (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    balance INT NOT NULL,
    PRIMARY KEY(id)
);

# Insert values to the table

INSERT INTO bank_accounts(name, balance) 
VALUES('Charlie', 10000);

INSERT INTO bank_accounts(name, balance)
VALUES('Dora', 25000);

SELECT * FROM bank_accounts;

# It inserted a new row into the accounts table
# Performing a sequence of steps that needs to be done atomically in a transaction
# A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block.

BEGIN;

UPDATE bank_accounts
SET balance = balance - 100
WHERE name = 'Charlie';

UPDATE bank_accounts
SET balance = balance + 100
WHERE name = 'Dora';

COMMIT;

SELECT * FROM bank_accounts;
# The amounts have been debited and credited atomically

# "Charlie" 9900
# "Dora"  25100


# Rolling back a transaction
INSERT INTO bank_accounts(name, balance)
VALUES('Jack', 1000);

SELECT * FROM bank_accounts;


# 3 records in the database has been added Charlie, Dora, and Jack
# Note : Select one command at a time and execute using F5


BEGIN;

UPDATE bank_accounts
SET balance = balance - 1500
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 1500
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;


# At the end should see 3 records
# "Charlie" 9900
# "Dora"  25100
# "Jack"  1000

# Rolling back a committed transaction
BEGIN;

UPDATE bank_accounts
SET balance = balance - 900
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance + 900
WHERE name = 'Dora';

SELECT * FROM bank_accounts;

COMMIT;

ROLLBACK;

SELECT * FROM bank_accounts;


# The rollback command should give you a warning, no transaction in progress
# The table will also have the updates made
# I.e, we cannot rollback a committed transaction

# Savepoints
BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Julia', 100000);

SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

UPDATE bank_accounts
SET balance = balance - 2000
WHERE name = 'Julia';

UPDATE bank_accounts
SET balance = balance + 2000
WHERE name = 'Jack';

SELECT * FROM bank_accounts;

ROLLBACK TO SAVEPOINT inserted_julia;

SELECT * FROM bank_accounts;

ROLLBACK;

SELECT * FROM bank_accounts;

# After rolling back to the savepoint one should be able to see Julia in the bank_accounts
# After rolling back completely one should see only the original 3 records Charlie, Dora, Jack

# Transaction isolation levels READ COMMITTED by default
# Note : First only select BEGIN and the INSERT COMMAND and run

BEGIN;

INSERT INTO bank_accounts(name, balance)
VALUES('Nancy', 15000);


# Run in the current session (Query Table 1)
SELECT * FROM bank_accounts;
# Should not be able to see the record for Nancy (Query Table 2)
SELECT * FROM bank_accounts;
# Commit the transaction
COMMIT;
# After commit now we are able to see the record for Nancy
SELECT * FROM bank_accounts;

# REPEATABLE READ

BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
## ---- Query Table 1
SELECT * FROM bank_accounts;

# The data is present
## ----- Query TABLE 2

BEGIN;

UPDATE bank_accounts 
SET balance = 10000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;


# The balance for Jack should be 10000


## ----- Query Tbale 1
# Execute the commands by selecting and running one at a time


SELECT * FROM bank_accounts;

COMMIT;


# Multiple reads in the same transaction got different results 


--------


# To avoid this we can use repeatable read isolation level

## ----- Query Table 1

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM bank_accounts;

# We see the balance is now 10000 for Jack


## ----- Query Table 2
BEGIN;

UPDATE bank_accounts 
SET balance = 20000
WHERE name = 'Jack';

COMMIT;

SELECT * FROM bank_accounts;

# We see the balance is now 20000 for Jack



## ----- Query Table 1
SELECT * FROM bank_accounts;

# We see the balance did not change in Query Table 1 tt is still 10000 for Jack
# commit and see in Query Table 1
COMMIT;
SELECT * FROM bank_accounts;

# We see now the balance is changed to 20000


## SERIALIZABLE
# Concurrent changes should be blocked and for that we can use serialization isolation level


# Begin a transaction and update the balance for Nancy


## ----- Query Table 1
BEGIN;
UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';
SELECT * FROM bank_accounts;

# We see the balance is updated Nancy should have 0 balance
## ----- Query Table 2
BEGIN;
UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';
SELECT * FROM bank_accounts;


# We see the update statement is not completed
# The query runs for a long time till we commit the transaction in Query Table 1


# Go back to Query Table 1 and commit

## ----- Query Table 1
# Add this to the very bottom

COMMIT;


## ----- Query Table 2

# Now check the query in Query Table 2  the query has run successfully
# This is because PostgreSQL places a lock to prevent another update until the first transaction is finished

# Now commit the second query's transaction 

COMMIT;
SELECT * FROM bank_accounts;

# Now if we check Nancy's balance it is 10000 and not 0
# So the first transaction’s change is lost, because the second one “overwrote” the row


---------------

# To avoid this let's use serialization


## ----- Query Table 1
BEGIN;
UPDATE bank_accounts 
SET balance = 0
WHERE name = 'Nancy';
SELECT * FROM bank_accounts;


# Here Nancy's balance should be 0



## ----- Query Table 2
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE bank_accounts 
SET balance = 100000
WHERE name = 'Nancy';
SELECT * FROM bank_accounts;


# We see the query will not end
# Go back to Query Table 1 and commit

## ----- Query Table 1
COMMIT;

# Now check Query Table 2 and the query is not executed
# It throws error:
# ERROR:  could not serialize access due to concurrent update













